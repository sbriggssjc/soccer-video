"""Fit lightweight polynomial expressions for FFmpeg crop automation."""
from __future__ import annotations

import argparse
import csv
from pathlib import Path
from typing import Dict, List, Optional, Sequence, Tuple

import numpy as np
import yaml


def deep_update(base: Dict, override: Dict) -> Dict:
    result = dict(base)
    for key, value in override.items():
        if isinstance(value, dict) and isinstance(result.get(key), dict):
            result[key] = deep_update(result[key], value)
        else:
            result[key] = value
    return result


def load_zoom_bounds(config_path: Path, profile: str, roi: str) -> Tuple[float, float]:
    with config_path.open("r", encoding="utf-8") as handle:
        data = yaml.safe_load(handle) or {}

    defaults = data.get("defaults", {})
    profiles = data.get("profiles", {})
    rois = data.get("roi", {})

    cfg = dict(defaults)
    if profile in profiles:
        cfg = deep_update(cfg, profiles[profile])
    if roi in rois:
        cfg = deep_update(cfg, rois[roi])

    zoom_cfg = cfg.get("zoom", {})
    z_min = float(zoom_cfg.get("min", 1.05))
    z_max = float(zoom_cfg.get("max", 2.4))
    if z_min > z_max:
        z_min, z_max = z_max, z_min
    return z_min, z_max


def read_track(
    csv_path: Path,
) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, Dict[str, str]]:
    metadata: Dict[str, str] = {}
    frames: List[int] = []
    cx: List[float] = []
    cy: List[float] = []
    zoom: List[float] = []

    with csv_path.open("r", encoding="utf-8", newline="") as handle:
        header_row: Optional[List[str]] = None
        while True:
            line = handle.readline()
            if not line:
                break
            stripped = line.strip()
            if not stripped:
                continue
            if stripped.startswith("#"):
                payload = stripped[1:].strip()
                if payload:
                    for part in payload.split(","):
                        if "=" in part:
                            key, value = part.split("=", 1)
                            metadata[key.strip()] = value.strip()
                continue
            header_row = next(csv.reader([line]))
            break

        if header_row is None:
            raise SystemExit(f"No header row found in {csv_path}")

        reader = csv.DictReader(handle, fieldnames=header_row)
        for row in reader:
            if row is None:
                continue
            frame_str = row.get("frame")
            cx_str = row.get("cx")
            cy_str = row.get("cy")
            z_str = row.get("z")
            if not frame_str or cx_str is None or cy_str is None or z_str is None:
                continue
            try:
                frames.append(int(float(frame_str)))
                cx.append(float(cx_str))
                cy.append(float(cy_str))
                zoom.append(float(z_str))
            except ValueError:
                continue

    if not frames:
        raise SystemExit(f"No rows found in {csv_path}")

    order = np.argsort(frames)
    frames_arr = np.asarray(frames, dtype=np.int64)[order]
    cx_arr = np.asarray(cx, dtype=np.float64)[order]
    cy_arr = np.asarray(cy, dtype=np.float64)[order]
    zoom_arr = np.asarray(zoom, dtype=np.float64)[order]
    return frames_arr, cx_arr, cy_arr, zoom_arr, metadata


def fit_poly(values: Sequence[float], degree: int) -> np.ndarray:
    arr = np.asarray(values, dtype=np.float64)
    if arr.ndim != 1:
        raise ValueError("values must be 1-D")
    if len(arr) <= degree:
        raise ValueError("not enough samples for requested degree")
    n = np.arange(len(arr), dtype=np.float64)
    coeffs = np.polyfit(n, arr, degree)
    return coeffs[::-1]  # convert to [a0, a1, ...]


def format_coeff(value: float) -> str:
    if abs(value) < 1e-9:
        value = 0.0
    return f"{value:.8g}"


def build_expr(coeffs: Sequence[float]) -> str:
    terms: List[str] = []
    for power, coeff in enumerate(coeffs):
        coeff_str = format_coeff(float(coeff))
        if power == 0:
            terms.append(f"({coeff_str})")
        else:
            n_term = "*".join(["n"] * power)
            terms.append(f"({coeff_str})*{n_term}")
    joined = "+".join(terms)
    return f"({joined})"


def write_ps1vars(out_path: Path, cx_expr: str, cy_expr: str, z_expr: str) -> None:
    out_path.parent.mkdir(parents=True, exist_ok=True)
    with out_path.open("w", encoding="utf-8") as handle:
        handle.write("# Auto-generated polynomial expressions\n")
        handle.write(f"$cxExpr = \"{cx_expr}\"\n")
        handle.write(f"$cyExpr = \"{cy_expr}\"\n")
        handle.write(f"$zExpr = \"{z_expr}\"\n")


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Fit FFmpeg-ready expressions from motion tracks")
    parser.add_argument("--csv", type=Path, required=True, help="CSV generated by autoframe.py")
    parser.add_argument("--out", type=Path, required=True, help="Destination .ps1vars file")
    parser.add_argument("--degree", type=int, choices=[2, 3], default=3, help="Polynomial degree")
    parser.add_argument("--profile", choices=["portrait", "landscape"], default="portrait")
    parser.add_argument("--roi", choices=["generic", "goal"], default="generic")
    parser.add_argument("--config", type=Path, default=Path("configs/zoom.yaml"))
    parser.add_argument("--no-clip", action="store_true", help="Skip wrapping z polynomial in clip()")
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    frames, cx, cy, zoom, metadata = read_track(args.csv)
    z_min, z_max = load_zoom_bounds(args.config, args.profile, args.roi)

    if "zoom_min" in metadata:
        try:
            z_min = float(metadata["zoom_min"])
        except ValueError:
            pass
    if "zoom_max" in metadata:
        try:
            z_max = float(metadata["zoom_max"])
        except ValueError:
            pass
    if z_min > z_max:
        z_min, z_max = z_max, z_min

    zoom = np.clip(zoom, z_min, z_max)

    cx_coeffs = fit_poly(cx, args.degree)
    cy_coeffs = fit_poly(cy, args.degree)
    z_coeffs = fit_poly(zoom, args.degree)

    cx_expr = build_expr(cx_coeffs)
    cy_expr = build_expr(cy_coeffs)
    z_expr_core = build_expr(z_coeffs)

    if args.no_clip:
        z_expr = z_expr_core
    else:
        z_expr = (
            f"(clip({z_expr_core},{format_coeff(z_min)},{format_coeff(z_max)}))"
        )

    write_ps1vars(args.out, cx_expr, cy_expr, z_expr)

    print(f"Frames: {len(frames)}  degree={args.degree}")
    print(f"cx: {cx_expr}")
    print(f"cy: {cy_expr}")
    print(f"z:  {z_expr}")


if __name__ == "__main__":
    main()
