"""Detect and repair bad timestamps in atomic_index.csv.

Some clips have filename timestamps encoded in non-standard units (60x for
clips originally generated by the pipeline, or 1440x for clips from an
older encoding). This tool:

  1. Detects clips with negative duration (t_end < t_start) in the CSV
  2. Finds correct timestamps from portrait counterparts when available
  3. Falls back to dividing filename timestamps by 60 or 1440
  4. Updates atomic_index.csv in place

Usage:
    python tools/fix_timestamps.py --scan     # Report bad timestamps
    python tools/fix_timestamps.py --fix      # Apply fixes
    python tools/fix_timestamps.py --dry-run  # Preview fixes
"""
from __future__ import annotations

import argparse
import csv
import re
import sys
from pathlib import Path
from typing import Dict, List, Optional, Sequence, Tuple

ROOT = Path(__file__).resolve().parents[1]
CATALOG_DIR = ROOT / "out" / "catalog"
ATOMIC_INDEX = CATALOG_DIR / "atomic_index.csv"

# Regex to extract timestamps from filename
FILENAME_TS_RE = re.compile(r"__t(-?\d+(?:\.\d+)?)-t?(-?\d+(?:\.\d+)?)")


def _parse_game_and_num(clip_name: str) -> Tuple[Optional[str], Optional[str]]:
    """Extract game name and clip number from clip_name."""
    num_m = re.match(r"^(\d+)__", clip_name)
    game_m = re.search(r"(\d{4}-\d{2}-\d{2}__\S+?_vs_\S+?)__", clip_name)
    clip_num = num_m.group(1) if num_m else None
    game = game_m.group(1) if game_m else None
    return game, clip_num


def _filename_timestamps(clip_name: str) -> Tuple[Optional[float], Optional[float]]:
    """Extract raw timestamps from filename."""
    m = FILENAME_TS_RE.search(clip_name)
    if m:
        return float(m.group(1)), float(m.group(2))
    return None, None


def load_index() -> Tuple[List[str], List[dict]]:
    """Load atomic_index.csv, return (fieldnames, rows)."""
    with ATOMIC_INDEX.open("r", encoding="utf-8", newline="") as f:
        reader = csv.DictReader(f)
        fieldnames = reader.fieldnames or []
        rows = list(reader)
    return list(fieldnames), rows


def build_portrait_lookup(rows: List[dict]) -> Dict[Tuple[str, str], Tuple[float, float]]:
    """Build lookup of (game, clip_num) -> (t_start, t_end) from portrait clips."""
    lookup = {}
    for row in rows:
        name = row.get("clip_name", "")
        if "portrait" not in name.lower():
            continue
        game, clip_num = _parse_game_and_num(name)
        if not game or not clip_num:
            continue
        try:
            ts = float(row.get("t_start_s", "") or "0")
            te = float(row.get("t_end_s", "") or "0")
        except ValueError:
            continue
        if ts > 0 and te > ts:
            lookup[(game, clip_num)] = (ts, te)
    return lookup


def find_broken_clips(rows: List[dict]) -> List[dict]:
    """Find clips where t_end < t_start (negative duration)."""
    broken = []
    for row in rows:
        name = row.get("clip_name", "")
        if "portrait" in name.lower():
            continue
        try:
            ts = float(row.get("t_start_s", "") or "0")
            te = float(row.get("t_end_s", "") or "0")
        except ValueError:
            continue
        if te < ts and ts > 0:
            broken.append(row)
    return broken


def compute_fix(
    row: dict,
    portrait_lookup: Dict[Tuple[str, str], Tuple[float, float]],
) -> Optional[Tuple[float, float, str]]:
    """Compute fixed timestamps for a broken clip.

    Returns (new_start, new_end, method) or None.
    """
    name = row.get("clip_name", "")
    game, clip_num = _parse_game_and_num(name)

    # Strategy 1: Portrait counterpart
    if game and clip_num:
        port = portrait_lookup.get((game, clip_num))
        if port:
            return port[0], port[1], "portrait"

    # Strategy 2: Divide filename timestamps
    fn_start, fn_end = _filename_timestamps(name)
    if fn_start is None or fn_end is None:
        return None

    # Try /60 first (standard pipeline encoding)
    fix60_s, fix60_e = fn_start / 60, fn_end / 60
    if fix60_s < 7200 and fix60_e < 7200 and fix60_e > fix60_s:
        return fix60_s, fix60_e, "/60"

    # Try /1440 for very large values (older encoding)
    fix1440_s, fix1440_e = fn_start / 1440, fn_end / 1440
    if fix1440_s < 7200 and fix1440_e > fix1440_s:
        return fix1440_s, fix1440_e, "/1440"

    return None


def scan(rows: List[dict]) -> None:
    """Print a report of bad timestamps."""
    portrait = build_portrait_lookup(rows)
    broken = find_broken_clips(rows)

    if not broken:
        print("No broken timestamps found.")
        return

    print(f"Found {len(broken)} clips with broken timestamps:\n")
    for row in broken:
        name = row.get("clip_name", "")
        ts = row.get("t_start_s", "")
        te = row.get("t_end_s", "")
        fix = compute_fix(row, portrait)
        print(f"  {name[:80]}")
        print(f"    Current: t_start={ts}, t_end={te}")
        if fix:
            print(f"    Fix ({fix[2]}): t_start={fix[0]:.2f}, t_end={fix[1]:.2f}, dur={fix[1]-fix[0]:.1f}s")
        else:
            print(f"    No automatic fix available")
        print()


def apply_fixes(rows: List[dict], *, dry_run: bool = False) -> int:
    """Fix broken timestamps in rows. Returns count of fixes applied."""
    portrait = build_portrait_lookup(rows)
    fixed = 0

    for row in rows:
        name = row.get("clip_name", "")
        if "portrait" in name.lower():
            continue
        try:
            ts = float(row.get("t_start_s", "") or "0")
            te = float(row.get("t_end_s", "") or "0")
        except ValueError:
            continue
        if te >= ts or ts <= 0:
            continue

        fix = compute_fix(row, portrait)
        if not fix:
            print(f"  SKIP (no fix): {name[:70]}")
            continue

        new_start, new_end, method = fix
        if dry_run:
            print(f"  [DRY-RUN] {name[:60]} -> t{new_start:.2f}-t{new_end:.2f} ({method})")
        else:
            row["t_start_s"] = str(new_start)
            row["t_end_s"] = str(new_end)
            row["duration_s"] = f"{new_end - new_start:.3f}"
            print(f"  FIXED: {name[:60]} -> t{new_start:.2f}-t{new_end:.2f} ({method})")
        fixed += 1

    return fixed


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("--scan", action="store_true", help="Report bad timestamps")
    group.add_argument("--fix", action="store_true", help="Apply fixes to atomic_index.csv")
    parser.add_argument("--dry-run", action="store_true", help="Preview fixes without writing")
    return parser


def main(argv: Sequence[str] | None = None) -> int:
    args = build_parser().parse_args(argv)
    fieldnames, rows = load_index()

    if args.scan:
        scan(rows)
        return 0

    fixed = apply_fixes(rows, dry_run=args.dry_run)
    print(f"\n{fixed} clips fixed")

    if fixed and not args.dry_run:
        with ATOMIC_INDEX.open("w", encoding="utf-8", newline="") as f:
            writer = csv.DictWriter(f, fieldnames=fieldnames, extrasaction="ignore")
            writer.writeheader()
            writer.writerows(rows)
        print(f"Updated {ATOMIC_INDEX}")

    return 0


if __name__ == "__main__":
    sys.exit(main())
